# shortLink-go

## 说在前面

### 什么是短链接？

常见的链接一般都是这样：[https://github.com/hobbyGG/shortLink-go](https://github.com/hobbyGG/shortLink-go),短链接顾名思义就是长度很短的一个链接，如下图所示。
![short link](static/916299411bbb32cb750408022c38fea.jpg)
一般都是`[域名]/[标识符]`这种格式，`/`后的位数受发送数量的影响

### 为什么要短链接

- 一些网址的path可能会附带uid等信息，这些信息会导致链接变得非常长，如果这个链接需要附在一条消息中会影响消息阅读的方便性。
- 对于会涉及发短信的业务，如果链接长度过长也会导致发短信的费用增加。
- 短链接生成的二维码会比长链接更稀疏，利于识别。

## 需求分析

### 需求背景

业务需要发送大量营销短信，需要一个短链接服务满足业务使用。

### 需求描述

给定一个长链接，得到对应唯一的短链接。

短链接必须长期有效。

### 需求拆解

#### 转链功能

- 相同长链转为同一个短链
- 短链长度尽量短

-------- ↑来自PM | ↓自行分析 --------

- 避免出现一些不合适的词
- 避免出现如`health`这种有实际功能的词
- 短链不能重复

#### 存储模块

该需求对于数据库属于读多写少

## 基本原理

浏览器通过DNS找到短链接对应的服务器并发出**get请求** ->

短链接服务器通过**标识符**查数据库，得到**长链接服务器的URL**，最后将这个URL放入响应头的`location`字段中并返回**302重定向** ->

 浏览器收到重定向请求就会从响应头中的`location`字段得到需要重定向到的地址，再次进行访问。

demo文件夹中通过gin简单实现了这一过程。

## 设计方案

### hash方式

通过hash使长链接和短链接一一对应，可以使用redis实现。

### 发号器

收到短链请求后生成一个递增的序号，将这个序号转为62进制的数再与域名进行拼接。

使用62进制的原因是可能出现在url中的字符一般为数字和字母，10个数字+52个大小写字母。

#### 发号器的实现方式

- 基于uuid生成编号
- 基于redis实现发号器
- 基于Mysql实现发号器
- 基于雪花算法实现发号器

**uuid**:

**snowflake**:

#### 使用Mysql实现

需要使用两张表，一张作为发号器使用，另一张就是实现对照功能的表。

作为发号器的表名为`sequence`，对照表名问`short_url_map`，对于sequence我们只使用replace插入，replace会将插入数据与数据库已有数据进行对比，具体来说是将主键或者唯一约束的进行比较，如果有一样的就会进行替换，这样sequence表大小就不会变，节省了空间。
